<html>

<head>
  <style type="text/css">

    @import url("https://fonts.googleapis.com/css2?family=Montserrat&display=swap");

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: "Montserrat", sans-serif;
      color: #262626;
      font-size: 1rem;
    }

    html {
      font-size: 16px;
      background-color: #fdfdfd;
    }

    #wrapper {
      margin: 1rem auto;
      max-width: 90%;
    }

    h1 {
      margin-bottom: 1.5rem;
      text-align: center;
      font-size: 1.25rem;
    }

    textarea {
      width: 100%;
      border: 1px solid rgba(0, 0, 0, 0.25);
      border-radius: 2px;
      padding: 0.5rem;
    }

    input {
      width: 100%;
      margin-top: 0.25rem;
      border: 1px solid rgba(0, 0, 0, 0.25);
      padding: 0.5rem;
      border-radius: 2px;
      font-size: 0.9rem;
    }

    #buttons {
      margin-top: 1.5rem;
      display: flex;
      justify-content: center;
    }

    button {
      font-size: 0.95rem;
      padding: 0.25rem 0.5rem;
      border: 1px solid rgba(0, 0, 0, 0.25);
      border-radius: 2px;
      cursor: pointer;
      box-shadow: 0 1px 1px rgba(0, 0, 0, 0.25);
    }

    button:active {
      box-shadow: none;
    }

  </style>
</head>



<body>
  <div id="wrapper">
    <h1>Speech Recognition - Dictaphone</h1>
    <textarea id="final_text" cols="30" rows="10"></textarea>
    <div id="buttons">
      <button id=PPT class="PPT">PPT</button>
      <button class="start">Старт</button>
      <button class="stop">Стоп</button>
    </div>
  </div>
</body>



<script type="text/javascript">

  var Voice = {};
  var UI = {};
  var Rec = {};
  var Game = {};

function getRandomFrom(arr)
{
  var rand = Math.floor(Math.random() * arr.length);
  return arr[rand];
}

  function getRandom(min, max) {
    return Math.random() * (max - min) + min;
  }
  function getRandomInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
  return Math.floor(Math.random() * (max - min) + min); // The maximum is exclusive and the minimum is inclusive
}

class ClassUI 
{
  constructor()
  {
    this.button_callbacks = {};
    document.addEventListener("keydown", this.__onkey.bind(this));
    document.addEventListener("keyup", this.__onkey.bind(this));
  }

  __onkey(e)
  {
    if (e.repeat == true)
      return;
    if (this.button_callbacks[e.key] != undefined)
      this.button_callbacks[e.key](e.type == "keydown");
  }

  showMessage(message)
  {
    final_text.value += message +"\n";
  }

  addOnKeyCallback(button, callback)
  {
    this.button_callbacks[button] = callback;
  }

}

class Speaker
{
  constructor(n, rate, pitch)
  {
    this.n = n;
    this.rate = rate;
    this.pitch = pitch;
    this.stoped = true;
    this.state = "after_ping";
    this.next_state = "after_ping";
    this.time = -5;
    this.context = "default";
  }

  update(ifps)
  {
    if (this.stoped)
      return;
    console.log("here state " + this.state);
    switch (this.state) {
    case "waiting_time":
      {
        this.time-=ifps;
        if (this.time <= 0)
          this.state = this.next_state;
        return;
      }
      break;
    case "speak":
      {
        if (!Voice.isActive())
        {
          Voice.speak(this.speak_phrase,this.rate, this.pitch);
          UI.showMessage(this.speak_phrase);
          this.state = this.next_state;
        }
        return;
      }
      break;
    case "ping":
      {
        this.speak_phrase = "лиса "+ this.n + " работает на отклик";
        this.state = "speak";
        this.next_state = "after_ping";
        return;
      }
      break;
    case "after_ping":
      {
        this.state = "waiting_time";
        this.time = 10 + getRandom(0,10);
        if(getRandom(0,1) > 0.9)
          this.next_state = "request";
        else
          this.next_state = "ping";
        this.context = "default";
        return;
      }
      break; 
    case "request":
      {
        this.speak_phrase = "Заря ответь лисе "+ this.n;
        this.state = "speak";
        this.next_state = "after_request";
        this.context = "waiting_for_call";
        return;
      }
      break;
    case "after_request":
      {

        this.state = "waiting_time"
        this.time = 10;
        this.next_state = "request";
        return;
      }
      break;
    default:
        // statements_def
      break;
    }
  }


  check_message(message)
  {
    console.log("here message " + message);

    if (message.includes("всем") && message.includes("брейк"))
      this.stoped = true;

    if (message.includes("всем") && message.includes("продолжаем"))
      this.stoped = false;


    if (message.includes("лиса " + this.n))
    {
      this.speak_phrase = "лиса " + this.n + " в канале";
      this.state = "speak";
      this.next_state = "after_ping";
      this.context = "waiting_for_command";
      return true;
    } 
    if (message.includes("заря в канале") && context == "waiting_for_call")
    {
       this.speak_phrase = getRandomFrom(["нашли носки", "нашли перчатки", "нашли пакет"]);
      this.state = "speak";
      this.next_state = "after_ping";
      this.context = "default";
      return true;
    }

    if (this.context == "waiting_for_command")
    {
      this.speak_phrase = "принято " + message + ". на приеме";
      this.state = "speak";
      this.next_state = "after_ping";
      this.context = "default";
      return true;
    }

    return false;

  }

  next()
  {}

  call()
  {

  }
}

class SpeakerGame
{
  constructor(size)
  {
    this.started = true;
    this.pool = [];
    for (let i = 0; i < size; i++)
      this.pool.push(new Speaker(i, getRandom(0.8, 1.3), getRandom(0.5,1.4)));

    setInterval(this.update.bind(this), 100);
  }

  update()
  {
    if (!this.started)
      return;
    for (let s of this.pool)
    {
      s.update(0.1);
    }
  }

  check_message(message)
  {
    for (let s of this.pool)
    {
      if (s.check_message(message))
        return;
    }
  }
}

class Voicer
{
  constructor()
  {
    this.U = new SpeechSynthesisUtterance();
    speechSynthesis.onvoiceschanged = this.__onvoiceschanged_callback.bind(this);
  }
  __onvoiceschanged_callback()
  {
    this.voices = speechSynthesis.getVoices();
    this.defaultVoiceIndex = this.voices.findIndex((voice) => voice.name === "Google русский");
  }

  speak(message, rate = 1, pitch = 1)
  {
   this.U.text = message;
   this.U.voice = this.voices[this.defaultVoiceIndex];
   this.U.lang = "ru-RU";
   this.U.volume = 1;
   this.U.rate = rate;
   this.U.pitch = pitch;
   speechSynthesis.speak(this.U);
 }

 isActive()
 {
  return speechSynthesis.speaking;
}


}

class Recoder
{
  constructor()
  {
    this.final_transcript = "";
    this.recognizing = false;

    const speechRecognition =
    window.SpeechRecognition || window.webkitSpeechRecognition;
    this.recognition = new speechRecognition();
    this.recognition.continuous = true;
    this.recognition.interimResults = true;
    this.recognition.maxAlternatives = 3;
    this.recognition.lang = "ru-RU";

    this.recognition.onstart = () => {
      console.log("Распознавание голоса запущено");
    };
    this. recognition.onerror = ({ error }) => {
      console.error(error);
    };
    this.recognition.onend = this.__onend_callback.bind(this);
    this.recognition.onresult = this.__onresult_callback.bind(this);
  }

  __onresult_callback(e)
  {
    console.log(e);
    if (this.recognizing)
    {
      for (let i = e.resultIndex; i < e.results.length; i++) 
      {
        if (e.results[i].isFinal) {
          let message = e.results[i][0].transcript;
          while(message.charAt(0) === ' ')
          {
           message = message.substring(1);
         }
         this.final_transcript += message + " ";

       }
     }
   }
 }
 __onend_callback()
 {
  console.log("Распознавание голоса закончено");
  this.onready(this.final_transcript);
  this.final_transcript = "";
   this.recognizing = false;
}

start()
{
  if (this.recognizing)
    return;
  this.recognition.start();
  this.final_transcript = "";
  this.recognizing = true;
}
stop()
{
  this.recognition.stop();
 

}



onready(e)
{
  console.log("ready: "+e);
  UI.showMessage(e);
  Game.check_message(e.toLowerCase());
}
}

let PPTSTART = ()=>{
  if (Voice.isActive())
  {
    UI.showMessage("Ошибка!");
    return;
  }
  Rec.start();
};
let PPTEND = ()=>{
  Rec.stop();
};

window.onload = function() 
{
  UI = new ClassUI();
  Voice = new Voicer();
  Rec = new Recoder();
  Game = new SpeakerGame(5);

  UI.addOnKeyCallback(" ", (e)=>{
    if (e)
    {
      PPTSTART();
    }
    else
    {
      PPTEND();
    }
  })

  PPT.onmousedown = ()=>{ PPTSTART(); };
  PPT.onmouseup = ()=>{ PPTEND(); };

  

  buttons.onclick = ({ target }) => {
    switch (target.className) {
    case "start": Game.started = true;
      break;
    case "stop": Game.started = false;
      break;
    case "abort":
    default:
      break;
    }
  };

}
</script>
</html>